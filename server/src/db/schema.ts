import { sqliteTable, text, integer, index } from 'drizzle-orm/sqlite-core';
import { sql } from 'drizzle-orm';

/**
 * Recipes table - stores recipe information
 */
export const recipes = sqliteTable(
  'recipes',
  {
    id: text('id')
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    title: text('title').notNull(),
    description: text('description'),
    sourceUrl: text('source_url'),
    imageUrl: text('image_url'),
    prepTimeMinutes: integer('prep_time_minutes'),
    cookTimeMinutes: integer('cook_time_minutes'),
    servings: integer('servings'),
    notes: text('notes'),
    isFavorite: integer('is_favorite', { mode: 'boolean' }).default(false).notNull(),
    createdAt: integer('created_at', { mode: 'timestamp' })
      .default(sql`(unixepoch())`)
      .notNull(),
    updatedAt: integer('updated_at', { mode: 'timestamp' })
      .default(sql`(unixepoch())`)
      .notNull(),
  },
  (table) => ({
    titleIdx: index('recipes_title_idx').on(table.title),
    favoriteIdx: index('recipes_favorite_idx').on(table.isFavorite),
  })
);

/**
 * Recipe ingredients table - stores ingredients for each recipe
 */
export const recipeIngredients = sqliteTable(
  'recipe_ingredients',
  {
    id: text('id')
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    recipeId: text('recipe_id')
      .notNull()
      .references(() => recipes.id, { onDelete: 'cascade' }),
    ingredientName: text('ingredient_name').notNull(),
    quantity: text('quantity'), // Store as string like "1-2" or "1/2"
    unit: text('unit'), // cups, tbsp, etc.
    notes: text('notes'), // "diced", "optional", etc.
    orderIndex: integer('order_index').notNull().default(0),
  },
  (table) => ({
    recipeIdx: index('recipe_ingredients_recipe_idx').on(table.recipeId),
    ingredientIdx: index('recipe_ingredients_ingredient_idx').on(table.ingredientName),
  })
);

/**
 * Recipe steps table - stores cooking instructions
 */
export const recipeSteps = sqliteTable(
  'recipe_steps',
  {
    id: text('id')
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    recipeId: text('recipe_id')
      .notNull()
      .references(() => recipes.id, { onDelete: 'cascade' }),
    stepNumber: integer('step_number').notNull(),
    instruction: text('instruction').notNull(),
  },
  (table) => ({
    recipeIdx: index('recipe_steps_recipe_idx').on(table.recipeId),
  })
);

/**
 * Recipe tags table - stores tags for recipes
 */
export const recipeTags = sqliteTable(
  'recipe_tags',
  {
    id: text('id')
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    recipeId: text('recipe_id')
      .notNull()
      .references(() => recipes.id, { onDelete: 'cascade' }),
    tag: text('tag').notNull(),
    isAutoGenerated: integer('is_auto_generated', { mode: 'boolean' }).default(false).notNull(),
  },
  (table) => ({
    recipeIdx: index('recipe_tags_recipe_idx').on(table.recipeId),
    tagIdx: index('recipe_tags_tag_idx').on(table.tag),
  })
);

/**
 * Inventory table - stores available ingredients
 */
export const inventory = sqliteTable(
  'inventory',
  {
    id: text('id')
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    ingredientName: text('ingredient_name').notNull().unique(),
    notes: text('notes'),
    addedAt: integer('added_at', { mode: 'timestamp' })
      .default(sql`(unixepoch())`)
      .notNull(),
    updatedAt: integer('updated_at', { mode: 'timestamp' })
      .default(sql`(unixepoch())`)
      .notNull(),
  },
  (table) => ({
    ingredientIdx: index('inventory_ingredient_idx').on(table.ingredientName),
  })
);

/**
 * Meal plans table - stores planned meals
 */
export const mealPlans = sqliteTable(
  'meal_plans',
  {
    id: text('id')
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    date: integer('date', { mode: 'timestamp' }).notNull(),
    mealType: text('meal_type', { enum: ['breakfast', 'lunch', 'dinner'] }).notNull(),
    recipeId: text('recipe_id')
      .notNull()
      .references(() => recipes.id, { onDelete: 'cascade' }),
    position: integer('position').default(0).notNull(),
    createdAt: integer('created_at', { mode: 'timestamp' })
      .default(sql`(unixepoch())`)
      .notNull(),
  },
  (table) => ({
    dateIdx: index('meal_plans_date_idx').on(table.date),
    mealTypeIdx: index('meal_plans_meal_type_idx').on(table.mealType),
    dateAndTypeIdx: index('meal_plans_date_meal_type_idx').on(table.date, table.mealType),
  })
);

// Type exports for use in the application
export type Recipe = typeof recipes.$inferSelect;
export type NewRecipe = typeof recipes.$inferInsert;

export type RecipeIngredient = typeof recipeIngredients.$inferSelect;
export type NewRecipeIngredient = typeof recipeIngredients.$inferInsert;

export type RecipeStep = typeof recipeSteps.$inferSelect;
export type NewRecipeStep = typeof recipeSteps.$inferInsert;

export type RecipeTag = typeof recipeTags.$inferSelect;
export type NewRecipeTag = typeof recipeTags.$inferInsert;

export type Inventory = typeof inventory.$inferSelect;
export type NewInventory = typeof inventory.$inferInsert;

export type MealPlan = typeof mealPlans.$inferSelect;
export type NewMealPlan = typeof mealPlans.$inferInsert;
